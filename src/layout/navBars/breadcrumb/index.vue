<template>
  <div class="layout-navbars-breadcrumb-index">
    <Logo v-if="setIsShowLogo" />
    <Breadcrumb />
    <Horizontal :menuList="state.menuList" v-if="isLayoutTransverse" />
    <Tool />
  </div>
</template>

<script setup lang="ts" name="layoutBreadcrumbIndex">
import { useRoutesList } from '/@/stores/routesList';
import { useThemeConfig } from '/@/stores/themeConfig';
import mittBus from '/@/utils/mitt';

// 引入组件
const Breadcrumb = defineAsyncComponent(() => import('/@/layout/navBars/breadcrumb/breadcrumb.vue'));
const Tool = defineAsyncComponent(() => import('/@/layout/navBars/breadcrumb/tool.vue'));
const Logo = defineAsyncComponent(() => import('/@/layout/logo/index.vue'));
const Horizontal = defineAsyncComponent(() => import('/@/layout/navMenu/horizontal.vue'));

// 定义变量内容
const stores = useRoutesList();
const storesThemeConfig = useThemeConfig();
const { themeConfig } = storeToRefs(storesThemeConfig);
const { routesList } = storeToRefs(stores);
const route = useRoute();
const state = reactive({
  menuList: [] as RouteItems,
});

// 设置 logo 显示/隐藏
const setIsShowLogo = computed(() => {
  let { isShowLogo, layout } = themeConfig.value;
  return isShowLogo && layout === 'classic';
});
// 设置是否显示横向导航菜单
const isLayoutTransverse = computed(() => {
  let { layout, isClassicSplitMenu } = themeConfig.value;
  return  (isClassicSplitMenu && layout === 'classic');
});
// 设置/过滤路由（非静态路由/是否显示在菜单中）
const setFilterRoutes = () => {
  let { layout, isClassicSplitMenu } = themeConfig.value;
  if (layout === 'classic' && isClassicSplitMenu) {
    state.menuList = delClassicChildren(filterRoutesFun(routesList.value));
    const resData = setSendClassicChildren(route.path);
    mittBus.emit('setSendClassicChildren', resData);
  } else {
    state.menuList = filterRoutesFun(routesList.value);
  }
};
// 设置了分割菜单时，删除底下 children
const delClassicChildren = <T extends ChilType>(arr: T[]): T[] => {
  arr.map((v: T) => {
    if (v.children) delete v.children;
  });
  return arr;
};

// 路由过滤递归函数
const filterRoutesFun = <T extends RouteItem>(arr: T[]): T[] => {
  return arr.reduce<T[]>((acc, item) => {
    if (!item.meta?.is_hide) {
      const newItem = { ...item };
      if (newItem.children) newItem.children = filterRoutesFun(newItem.children);
      acc.push(newItem);
    }
    return acc;
  }, []);
};

// 传送当前子级数据到菜单中
const setSendClassicChildren = (path: string) => {
  let currentData: MittMenu = { children: [] };
  const route = searchParent(routesList.value, path as string);
  if (route) {
    const filteredRoutes = filterRoutesFun(routesList.value);
    const matchedRoute = filteredRoutes.find(v => v.path === route.path);
    if (matchedRoute) {
      currentData['item'] = { ...matchedRoute };
      currentData['children'] = matchedRoute.children || [];
    }
  }
  return currentData;
};

// 使用递归查询对应的父级路由
const searchParent = (routesList: any, path: string) => {
  for (const item of routesList) {
    if (item.path === path) return item;
    if (item.children) {
      const parent = searchParent(item.children, path);
      if (parent) return item;
    }
  }
  return undefined;
};

// 页面加载时
onMounted(() => {
  setFilterRoutes();
  mittBus.on('getBreadcrumbIndexSetFilterRoutes', () => {
    setFilterRoutes();
  });
});
// 页面卸载时
onUnmounted(() => {
  mittBus.off('getBreadcrumbIndexSetFilterRoutes', () => {});
});
</script>

<style scoped lang="scss">
.layout-navbars-breadcrumb-index {
  height: 55px;
  display: flex;
  align-items: center;
  padding: 0;
  background: var(--next-bg-topBar);
  border-bottom: 1px solid var(--next-border-color-light);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
  transition: all 0.3s ease;
  
  &:hover {
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
  }
  
  > * {
    margin: 0 10px;
    
    &:first-child {
      margin-left: 0;
    }
    
    &:last-child {
      margin-right: 0;
    }
  }
  
  .layout-navbars-breadcrumb {
    flex: 1;
  }
  
  .layout-navbars-tool {
    display: flex;
    align-items: center;
    padding: 5px 12px;
    border-radius: 20px;
    background: rgba(255, 255, 255, 0.2);
    transition: all 0.3s ease;
    
    &:hover {
      background: rgba(255, 255, 255, 0.3);
    }
  }
}
</style>